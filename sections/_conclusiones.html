<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>conclusiones</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_conclusiones_files/libs/clipboard/clipboard.min.js"></script>
<script src="_conclusiones_files/libs/quarto-html/quarto.js"></script>
<script src="_conclusiones_files/libs/quarto-html/popper.min.js"></script>
<script src="_conclusiones_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_conclusiones_files/libs/quarto-html/anchor.min.js"></script>
<link href="_conclusiones_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_conclusiones_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_conclusiones_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_conclusiones_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_conclusiones_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="conclusiones" class="level1">
<h1>Conclusiones</h1>
<p>Para efectos de este proyecto, se crearon tres algoritmos con distintas estategias. Cada uno de los algortimos implementados, se ejecutaron utilizando como entrada, los datos del archivo de datos mostrado en <strong>?@fig-datos</strong>.</p>
<p>Los algoritmos implementados fueron:</p>
<ol type="1">
<li>Fuerza Bruta</li>
<li>Función Hash y</li>
<li>Memorización (Greedy)</li>
</ol>
<p>Se espera que el algoritmo que implementa funciones de hash tenga el menor tiempo de ejecución de los tres.</p>
<section id="tiempo-de-ejecución-del-algoritmo-fuerza-bruta" class="level2">
<h2 class="anchored" data-anchor-id="tiempo-de-ejecución-del-algoritmo-fuerza-bruta">Tiempo de ejecución del algoritmo Fuerza Bruta</h2>
<p>Un algoritmo de fuerza bruta resuelve un problema por agotamiento: pasa por todas las opciones posibles hasta encontrar una solución. La complejidad temporal de un algoritmo de fuerza bruta suele ser proporcional al tamaño de la entrada. Los algoritmos de fuerza bruta son simples y consistentes, pero muy lentos.</p>
<div id="fig-tmp-fb" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Tiempo%20Fuerza%20Bruta.png" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Tiempo Fuerza Bruta</figcaption>
</figure>
</div>
<p>La implementación realizada en este proyecto resuelve la busqueda de un nombre en 0,00000429 segundos. Ese resultado puede verse en la <a href="#fig-tmp-fb">Figure&nbsp;1</a>.</p>
</section>
<section id="tiempo-de-ejecución-del-algoritmo-hash" class="level2">
<h2 class="anchored" data-anchor-id="tiempo-de-ejecución-del-algoritmo-hash">Tiempo de ejecución del algoritmo Hash</h2>
<p>Un <strong>HASH</strong> es una función matemática que convierte una entrada de longitud arbitraria en una salida cifrada de longitud fija. Por lo tanto, independientemente de la cantidad original de datos o del tamaño del archivo involucrado, su hash único siempre tendrá el mismo tamaño. Además, los <strong>hashes</strong> no se pueden utilizar para <strong>“realizar ingeniería inversa”</strong> en la entrada de la salida hash, ya que las funciones hash son “unidireccionales” (como una picadora de carne; no se puede volver a poner la carne molida en un filete). Aún así, si usa dicha función en los mismos datos, su hash será idéntico, por lo que puede validar que los datos sean los mismos (es decir, sin cambios) si ya conoce su hash <span class="citation" data-cites="WhatHashHash">[@WhatHashHash]</span>.</p>
<div id="fig-tmp-hash" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Tiempo%20Funcion%20Hash.png" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Tiempo Función Hash</figcaption>
</figure>
</div>
<p>El algoritmo Hash se ejecutó tres veces con el fin de ver los tiempos resultantes. Estos tiempos iban desde 0,00000834 hasta 0,0000269 segundos. Los resultados se pueden ver en la <a href="#fig-tmp-hash">Figure&nbsp;2</a>.</p>
</section>
<section id="tiempo-de-ejecución-del-algortimo-memorización" class="level2">
<h2 class="anchored" data-anchor-id="tiempo-de-ejecución-del-algortimo-memorización">Tiempo de ejecución del algortimo Memorización</h2>
<p>En informática, la memoización o memorización es una técnica de optimización que se utiliza principalmente para acelerar los programas de computadora almacenando los resultados de costosas llamadas a funciones en funciones puras y devolviendo el resultado almacenado en caché cuando las mismas entradas ocurren nuevamente. La memoización también se ha utilizado en otros contextos (y para fines distintos del aumento de velocidad), como en el análisis de descenso simple y mutuamente recursivo. Es un tipo de almacenamiento en caché, distinto de otras formas de almacenamiento en caché, como el almacenamiento en búfer y el reemplazo de páginas. En el contexto de algunos lenguajes de programación lógica, la memoización también se conoce como tabulación <span class="citation" data-cites="Memoization2023">[@Memoization2023]</span>.</p>
<div id="fig-tmp-memo" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Tiempo%20Greedy%20Memoizacion.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;3: Tiempo Memoizacion</figcaption>
</figure>
</div>
<p>Este algoritmo mostró un tiemo de respuesta de 0,0000774. La <a href="#fig-tmp-memo">Figure&nbsp;3</a> muestra el resultado en Colab de Google.</p>
</section>
<section id="comparativas" class="level2">
<h2 class="anchored" data-anchor-id="comparativas">Comparativas</h2>
<div id="fig-comp-tiempos" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Comparativa%20tiempos%20de%20Ejecucion.png" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;4: Comparativa de tiempos de ejecución</figcaption>
</figure>
</div>
<div id="fig-comp-log" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Comparativa%20a%20escala%20logaritmica.png" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;5: Comparativa a escala logarítmica de ejecuciones</figcaption>
</figure>
</div>
<div id="fig-colision" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/Colisiones%20Hash.png" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;6: Cantidad de colisiones</figcaption>
</figure>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>